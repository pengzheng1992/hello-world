!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
APP	Makefile	/^APP = carrot$/;"	m
APP_PATH	Makefile	/^APP_PATH = .\/$(APP)$/;"	m
CC	Makefile	/^CC = g++$/;"	m
CXXFLAGS	Makefile	/^CXXFLAGS = -std=c++11 -Wall -g -O3$/;"	m
DEV_ARGS	Makefile	/^DEV_ARGS = -p $(PCAP1) -t $(TOPO1)$/;"	m
DIAL_COMMON_H_	common.h	2;"	d
DIAL_FLOW_H_	flow.h	2;"	d
DIAL_PACKET_H_	packet.h	2;"	d
DIAL_PARSE_ARGS_H_	parse_args.h	2;"	d
DIAL_PLACE_H_	place.h	2;"	d
DIAL_STATISTICS_H_	statistics.h	2;"	d
DIAL_SWITCH_H_	switch.h	2;"	d
DIAL_TOPO_H_	topo.h	2;"	d
Flow	flow.h	/^	Flow() {};$/;"	f	class:Flow	access:public	signature:()
Flow	flow.h	/^	Flow(Tuple5 t5) : tuple5(t5) {	};$/;"	f	class:Flow	access:public	signature:(Tuple5 t5)
Flow	flow.h	/^	Flow(Tuple5 t5, unsigned int s, unsigned int d) :$/;"	f	class:Flow	access:public	signature:(Tuple5 t5, unsigned int s, unsigned int d)
Flow	flow.h	/^class Flow$/;"	c
Flow::Flow	flow.h	/^	Flow() {};$/;"	f	class:Flow	access:public	signature:()
Flow::Flow	flow.h	/^	Flow(Tuple5 t5) : tuple5(t5) {	};$/;"	f	class:Flow	access:public	signature:(Tuple5 t5)
Flow::Flow	flow.h	/^	Flow(Tuple5 t5, unsigned int s, unsigned int d) :$/;"	f	class:Flow	access:public	signature:(Tuple5 t5, unsigned int s, unsigned int d)
Flow::destSwitch	flow.h	/^	unsigned int destSwitch; \/\/ destination_network_segment;$/;"	m	class:Flow	access:public
Flow::nSwitches	flow.h	/^	int nSwitches; \/\/ sizeof switchesPath$/;"	m	class:Flow	access:public
Flow::operator <	flow.h	/^	bool operator < (Flow const & o) const {$/;"	f	class:Flow	access:public	signature:(Flow const & o) const
Flow::operator ==	flow.h	/^	bool operator == (const Flow &o) const {$/;"	f	class:Flow	access:public	signature:(const Flow &o) const
Flow::srcSwitch	flow.h	/^	unsigned int srcSwitch; \/\/ source_network_segment;$/;"	m	class:Flow	access:public
Flow::switchesPath	flow.h	/^	vector<pair<int, int>> switchesPath;$/;"	m	class:Flow	access:public
Flow::tuple5	flow.h	/^	Tuple5 tuple5;$/;"	m	class:Flow	access:public
Flow::~Flow	flow.h	/^	~Flow() {};$/;"	f	class:Flow	access:public	signature:()
IN	common.h	4;"	d
INF	topo.cpp	/^const int &INF = 100000000;$/;"	v
LDLIBS	Makefile	/^LDLIBS = -lpcap$/;"	m
MEM	main.cpp	/^const int MEM = kMaxCountersInSwitch * kSplitCounterWidth;$/;"	v
OBJS	Makefile	/^OBJS = main.o parse_args.o packet.o topo.o place.o statistics.o$/;"	m
OUT	common.h	5;"	d
PCAP1	Makefile	/^PCAP1 = ~\/pcap\/equinix-chicago.dirA.20160121-125911.UTC.anon.pcap$/;"	m
PCAP2	Makefile	/^PCAP2 = ~\/pcap\/equinix-chicago.dirA.20160218-130000.UTC.anon.pcap$/;"	m
PCAP3	Makefile	/^PCAP3 = ~\/pcap\/equinix-chicago.dirA.20160317-130100.UTC.anon.pcap$/;"	m
Packet	packet.h	/^struct Packet {$/;"	s
Packet::carry	packet.h	/^	bool carry;$/;"	m	struct:Packet	access:public
Packet::counted	packet.h	/^	bool counted;$/;"	m	struct:Packet	access:public
Packet::destSwitch	packet.h	/^	unsigned int destSwitch; \/\/ destination_network_segment;$/;"	m	struct:Packet	access:public
Packet::flow	packet.h	/^	bool flow;$/;"	m	struct:Packet	access:public
Packet::length	packet.h	/^	int length;$/;"	m	struct:Packet	access:public
Packet::srcSwitch	packet.h	/^	unsigned int srcSwitch; \/\/ source_network_segment;$/;"	m	struct:Packet	access:public
Packet::tuple5	packet.h	/^	struct Tuple5 tuple5;$/;"	m	struct:Packet	typeref:struct:Packet::Tuple5	access:public
RULES	main.cpp	/^const int RULES = kMaxCountersInSwitch;$/;"	v
Switch	switch.h	/^	Switch() {};$/;"	f	class:Switch	access:public	signature:()
Switch	switch.h	/^	Switch(int id) : identity(id) {	};$/;"	f	class:Switch	access:public	signature:(int id)
Switch	switch.h	/^	Switch(int id, int mem, int rules) :$/;"	f	class:Switch	access:public	signature:(int id, int mem, int rules)
Switch	switch.h	/^	Switch(int id, int mem, int rules, int width) :$/;"	f	class:Switch	access:public	signature:(int id, int mem, int rules, int width)
Switch	switch.h	/^class Switch {$/;"	c
Switch::Switch	switch.h	/^	Switch() {};$/;"	f	class:Switch	access:public	signature:()
Switch::Switch	switch.h	/^	Switch(int id) : identity(id) {	};$/;"	f	class:Switch	access:public	signature:(int id)
Switch::Switch	switch.h	/^	Switch(int id, int mem, int rules) :$/;"	f	class:Switch	access:public	signature:(int id, int mem, int rules)
Switch::Switch	switch.h	/^	Switch(int id, int mem, int rules, int width) :$/;"	f	class:Switch	access:public	signature:(int id, int mem, int rules, int width)
Switch::counterMemoryTotal	switch.h	/^	unsigned int counterMemoryTotal;$/;"	m	class:Switch	access:public
Switch::counterWidth	switch.h	/^	int counterWidth;$/;"	m	class:Switch	access:public
Switch::counters	switch.h	/^	std::unordered_map<Flow, int, flow_hash> counters;$/;"	m	class:Switch	access:public
Switch::flowTableCountingRuleEntriesTotal	switch.h	/^	unsigned int flowTableCountingRuleEntriesTotal;$/;"	m	class:Switch	access:public
Switch::identity	switch.h	/^	int identity;$/;"	m	class:Switch	access:public
Switch::~Switch	switch.h	/^	~Switch() {};$/;"	f	class:Switch	access:public	signature:()
TOPO1	Makefile	/^TOPO1 = ~\/topo\/fattree.txt$/;"	m
TOPO2	Makefile	/^TOPO2 = ~\/topo\/cernet.txt$/;"	m
TOPO3	Makefile	/^TOPO3 = ~\/topo\/chinanet.txt$/;"	m
Tuple5	packet.h	/^struct Tuple5 {$/;"	s
Tuple5::daddr	packet.h	/^	uint32_t daddr; \/\/ destination IP address$/;"	m	struct:Tuple5	access:public
Tuple5::dport	packet.h	/^	unsigned short dport; \/\/ destination port number$/;"	m	struct:Tuple5	access:public
Tuple5::ip_proto	packet.h	/^	unsigned char ip_proto; \/\/ protocol$/;"	m	struct:Tuple5	access:public
Tuple5::operator <	packet.h	/^	bool operator < (Tuple5 const &o) const {$/;"	f	struct:Tuple5	access:public	signature:(Tuple5 const &o) const
Tuple5::operator ==	packet.h	/^	bool operator == (const Tuple5 &o) const {$/;"	f	struct:Tuple5	access:public	signature:(const Tuple5 &o) const
Tuple5::saddr	packet.h	/^	uint32_t saddr; \/\/ source IP address$/;"	m	struct:Tuple5	access:public
Tuple5::sport	packet.h	/^	unsigned short sport; \/\/ source port number$/;"	m	struct:Tuple5	access:public
Tuple5Hash	packet.h	/^struct Tuple5Hash {$/;"	s
Tuple5Hash::operator ()	packet.h	/^	size_t operator () (const Tuple5 &o) const {$/;"	f	struct:Tuple5Hash	access:public	signature:(const Tuple5 &o) const
callback_carrot_count_flows	main.cpp	/^void callback_carrot_count_flows(u_char *args, const struct pcap_pkthdr *pcap_header, const u_char *pcap_content) {$/;"	f	signature:(u_char *args, const struct pcap_pkthdr *pcap_header, const u_char *pcap_content)
callback_findinitflows	main.cpp	/^void callback_findinitflows(u_char *args, const struct pcap_pkthdr *pcap_header, const u_char *pcap_content) {$/;"	f	signature:(u_char *args, const struct pcap_pkthdr *pcap_header, const u_char *pcap_content)
carrot_count_flow	main.cpp	/^void carrot_count_flow(IN OUT Flow &ff, IN OUT struct Packet *p_packet) {$/;"	f	signature:(IN OUT Flow &ff, IN OUT struct Packet *p_packet)
carrot_count_in_the_ith_switch	main.cpp	/^int carrot_count_in_the_ith_switch(IN OUT Flow &ff, IN OUT struct Packet *p_packet, IN int i) {$/;"	f	signature:(IN OUT Flow &ff, IN OUT struct Packet *p_packet, IN int i)
carrot_count_packet	main.cpp	/^void carrot_count_packet(IN OUT struct Packet *p_packet) {$/;"	f	signature:(IN OUT struct Packet *p_packet)
carrot_multi_place	place.cpp	/^void carrot_multi_place(IN OUT std::unordered_set<Flow, flow_hash> &fs)$/;"	f	signature:(IN OUT std::unordered_set<Flow, flow_hash> &fs)
carrot_multi_place	place.h	/^void carrot_multi_place(IN OUT std::unordered_set<Flow, flow_hash> &fs);$/;"	p	signature:(IN OUT std::unordered_set<Flow, flow_hash> &fs)
carrot_overflow_report	place.cpp	/^void carrot_overflow_report(IN OUT Flow &f, IN int i, IN int type) {$/;"	f	signature:(IN OUT Flow &f, IN int i, IN int type)
carrot_overflow_report	place.h	/^void carrot_overflow_report(IN OUT Flow &f, IN int i, IN int type);$/;"	p	signature:(IN OUT Flow &f, IN int i, IN int type)
carrot_place	place.cpp	/^int carrot_place(IN OUT Flow &f)$/;"	f	signature:(IN OUT Flow &f)
carrot_place	place.h	/^int carrot_place(IN OUT Flow &f);$/;"	p	signature:(IN OUT Flow &f)
carrot_upload	place.cpp	/^void carrot_upload(Flow &f) {$/;"	f	signature:(Flow &f)
carry	packet.h	/^	bool carry;$/;"	m	struct:Packet	access:public
collect_statistics	main.cpp	/^void collect_statistics() {$/;"	f	signature:()
count_in_the_ith_switch	main.cpp	/^int count_in_the_ith_switch(IN OUT Flow &ff, IN OUT struct Packet *p_packet, IN int i) {$/;"	f	signature:(IN OUT Flow &ff, IN OUT struct Packet *p_packet, IN int i)
counted	packet.h	/^	bool counted;$/;"	m	struct:Packet	access:public
counterMemoryTotal	switch.h	/^	unsigned int counterMemoryTotal;$/;"	m	class:Switch	access:public
counterWidth	switch.h	/^	int counterWidth;$/;"	m	class:Switch	access:public
counters	switch.h	/^	std::unordered_map<Flow, int, flow_hash> counters;$/;"	m	class:Switch	access:public
create_switches	main.cpp	/^void create_switches() {$/;"	f	signature:()
daddr	packet.h	/^	uint32_t daddr; \/\/ destination IP address$/;"	m	struct:Tuple5	access:public
destSwitch	flow.h	/^	unsigned int destSwitch; \/\/ destination_network_segment;$/;"	m	class:Flow	access:public
destSwitch	packet.h	/^	unsigned int destSwitch; \/\/ destination_network_segment;$/;"	m	struct:Packet	access:public
dport	packet.h	/^	unsigned short dport; \/\/ destination port number$/;"	m	struct:Tuple5	access:public
find_init_flows	main.cpp	/^void find_init_flows(IN struct Packet *p_packet) {$/;"	f	signature:(IN struct Packet *p_packet)
find_routing_path	main.cpp	/^void find_routing_path(IN OUT Flow &f) {$/;"	f	signature:(IN OUT Flow &f)
find_src_dest_switch	main.cpp	/^void find_src_dest_switch(IN OUT struct Packet *p_packet) {$/;"	f	signature:(IN OUT struct Packet *p_packet)
flow	packet.h	/^	bool flow;$/;"	m	struct:Packet	access:public
flowTableCountingRuleEntriesTotal	switch.h	/^	unsigned int flowTableCountingRuleEntriesTotal;$/;"	m	class:Switch	access:public
flow_hash	flow.h	/^struct flow_hash {$/;"	s
flow_hash::operator ()	flow.h	/^	size_t operator () (const Flow &o) const {$/;"	f	struct:flow_hash	access:public	signature:(const Flow &o) const
flows	main.cpp	/^static unordered_set<Flow, flow_hash> flows;$/;"	v	file:
floyd	topo.cpp	/^void floyd(vector<vector<int>> &adjacencyMatrix, vector<vector<int>> &nextHop) {$/;"	f	signature:(vector<vector<int>> &adjacencyMatrix, vector<vector<int>> &nextHop)
g_controller_counters	main.cpp	/^std::unordered_map<Flow, int, flow_hash> g_controller_counters;$/;"	v
g_controller_counters	place.cpp	/^extern std::unordered_map<Flow, int, flow_hash> g_controller_counters;$/;"	x
g_switches	main.cpp	/^vector<Switch*> g_switches;$/;"	v
g_switches	place.cpp	/^extern vector<Switch*> g_switches;$/;"	x
identity	switch.h	/^	int identity;$/;"	m	class:Switch	access:public
init_packet	main.cpp	/^void init_packet(IN const struct pcap_pkthdr *packet_header, IN const u_char **p_pcap_content, OUT struct Packet *p_packet) {$/;"	f	signature:(IN const struct pcap_pkthdr *packet_header, IN const u_char **p_pcap_content, OUT struct Packet *p_packet)
init_path	topo.cpp	/^void init_path(vector<vector<int>> &nextHop, int n_num) {$/;"	f	signature:(vector<vector<int>> &nextHop, int n_num)
ip2ns	main.cpp	/^unsigned int ip2ns(uint32_t ip) {$/;"	f	signature:(uint32_t ip)
ip_info_from_pcap	packet.cpp	/^void ip_info_from_pcap(IN const u_char **p_pcap_content, OUT struct Packet *p_packet) {$/;"	f	signature:(IN const u_char **p_pcap_content, OUT struct Packet *p_packet)
ip_info_from_pcap	packet.h	/^void ip_info_from_pcap(IN const u_char **p_pcap_content, OUT struct Packet *p_packet);$/;"	p	signature:(IN const u_char **p_pcap_content, OUT struct Packet *p_packet)
ip_proto	packet.h	/^	unsigned char ip_proto; \/\/ protocol$/;"	m	struct:Tuple5	access:public
kMaxCountersInSwitch	main.cpp	/^const int kMaxCountersInSwitch = INT_MAX \/ kSplitCounterWidth;$/;"	v
kSplitCounterWidth	main.cpp	/^extern const int kSplitCounterWidth = 13; \/\/ maybe <= 16bits$/;"	v
kSplitCounterWidth	place.cpp	/^extern const int kSplitCounterWidth;$/;"	x
kSwitches	main.cpp	/^const int kSwitches = 20; \/\/ how many switches we have in the topology file.$/;"	v
length	packet.h	/^	int length;$/;"	m	struct:Packet	access:public
lessSwitches	flow.h	/^struct lessSwitches {$/;"	s
lessSwitches::operator ()	flow.h	/^	bool operator () (const Flow & lhs, const Flow & rhs)  const {$/;"	f	struct:lessSwitches	access:public	signature:(const Flow & lhs, const Flow & rhs) const
main	main.cpp	/^int main(IN int argc, IN char *argv[]) {$/;"	f	signature:(IN int argc, IN char *argv[])
moreEmpty	switch.h	/^struct moreEmpty {$/;"	s
moreEmpty::operator ()	switch.h	/^	bool operator () (const Switch* lhs, const Switch* rhs)  const {$/;"	f	struct:moreEmpty	access:public	signature:(const Switch* lhs, const Switch* rhs) const
multi_place	place.cpp	/^void multi_place(IN OUT std::unordered_set<Flow, flow_hash> &fs)$/;"	f	signature:(IN OUT std::unordered_set<Flow, flow_hash> &fs)
nSwitches	flow.h	/^	int nSwitches; \/\/ sizeof switchesPath$/;"	m	class:Flow	access:public
nextHop	main.cpp	/^vector<vector<int>> nextHop(kSwitches, vector<int>(kSwitches));$/;"	p	file:	signature:(kSwitches, vector<int>(kSwitches))
open_file	topo.cpp	/^ifstream& open_file(ifstream &in, const string &file) {$/;"	f	signature:(ifstream &in, const string &file)
operator ()	flow.h	/^	bool operator () (const Flow & lhs, const Flow & rhs)  const {$/;"	f	struct:lessSwitches	access:public	signature:(const Flow & lhs, const Flow & rhs) const
operator ()	flow.h	/^	size_t operator () (const Flow &o) const {$/;"	f	struct:flow_hash	access:public	signature:(const Flow &o) const
operator ()	packet.h	/^	size_t operator () (const Tuple5 &o) const {$/;"	f	struct:Tuple5Hash	access:public	signature:(const Tuple5 &o) const
operator ()	switch.h	/^	bool operator () (const Switch* lhs, const Switch* rhs)  const {$/;"	f	struct:moreEmpty	access:public	signature:(const Switch* lhs, const Switch* rhs) const
operator <	flow.h	/^	bool operator < (Flow const & o) const {$/;"	f	class:Flow	access:public	signature:(Flow const & o) const
operator <	packet.h	/^	bool operator < (Tuple5 const &o) const {$/;"	f	struct:Tuple5	access:public	signature:(Tuple5 const &o) const
operator ==	flow.h	/^	bool operator == (const Flow &o) const {$/;"	f	class:Flow	access:public	signature:(const Flow &o) const
operator ==	packet.h	/^	bool operator == (const Tuple5 &o) const {$/;"	f	struct:Tuple5	access:public	signature:(const Tuple5 &o) const
overflow_report	place.cpp	/^void overflow_report(IN OUT Flow &f, IN int i, IN int type) {$/;"	f	signature:(IN OUT Flow &f, IN int i, IN int type)
packets_in_controller	main.cpp	/^long packets_in_controller = 0;$/;"	v
packets_in_controller	place.cpp	/^extern long packets_in_controller;$/;"	x
parse_args	parse_args.cpp	/^int parse_args(IN int argc, IN char **argv, OUT const char **pcap_file, OUT const char **topo_file) {$/;"	f	signature:(IN int argc, IN char **argv, OUT const char **pcap_file, OUT const char **topo_file)
parse_args	parse_args.h	/^int parse_args(IN int argc, IN char **argv, OUT const char **pcap_file, OUT const char **topo_file);$/;"	p	signature:(IN int argc, IN char **argv, OUT const char **pcap_file, OUT const char **topo_file)
place	place.cpp	/^int place(IN OUT Flow &f)$/;"	f	signature:(IN OUT Flow &f)
print_usage	parse_args.cpp	/^void print_usage() {$/;"	f	signature:()
print_usage	parse_args.h	/^void print_usage();$/;"	p	signature:()
random_multi_place	place.cpp	/^void random_multi_place(IN OUT std::unordered_set<Flow, flow_hash>& fs)$/;"	f	signature:(IN OUT std::unordered_set<Flow, flow_hash>& fs)
random_place	place.cpp	/^int random_place(IN OUT Flow & f)$/;"	f	signature:(IN OUT Flow & f)
saddr	packet.h	/^	uint32_t saddr; \/\/ source IP address$/;"	m	struct:Tuple5	access:public
show_results	main.cpp	/^void show_results() {$/;"	f	signature:()
show_switches	main.cpp	/^void show_switches() {$/;"	f	signature:()
sport	packet.h	/^	unsigned short sport; \/\/ source port number$/;"	m	struct:Tuple5	access:public
srcSwitch	flow.h	/^	unsigned int srcSwitch; \/\/ source_network_segment;$/;"	m	class:Flow	access:public
srcSwitch	packet.h	/^	unsigned int srcSwitch; \/\/ source_network_segment;$/;"	m	struct:Packet	access:public
standard_deviation	statistics.cpp	/^double standard_deviation(const int data[], int n, double average) {$/;"	f	signature:(const int data[], int n, double average)
standard_deviation	statistics.h	/^double standard_deviation(const int data[], int n, double average);$/;"	p	signature:(const int data[], int n, double average)
switchesPath	flow.h	/^	vector<pair<int, int>> switchesPath;$/;"	m	class:Flow	access:public
tcp_info_from_pcap	packet.cpp	/^void tcp_info_from_pcap(IN const u_char **p_pcap_content, OUT struct Packet *p_packet) {$/;"	f	signature:(IN const u_char **p_pcap_content, OUT struct Packet *p_packet)
tcp_info_from_pcap	packet.h	/^void tcp_info_from_pcap(IN const u_char **p_pcap_content, OUT struct Packet *p_packet);$/;"	p	signature:(IN const u_char **p_pcap_content, OUT struct Packet *p_packet)
topo	topo.cpp	/^void topo(const string &filename, vector<vector<int>> &nextHop) {$/;"	f	signature:(const string &filename, vector<vector<int>> &nextHop)
topo	topo.h	/^void topo(const std::string &filename, std::vector<std::vector<int>> &nextHop);$/;"	p	signature:(const std::string &filename, std::vector<std::vector<int>> &nextHop)
tuple5	flow.h	/^	Tuple5 tuple5;$/;"	m	class:Flow	access:public
tuple5	packet.h	/^	struct Tuple5 tuple5;$/;"	m	struct:Packet	typeref:struct:Packet::Tuple5	access:public
udp_info_from_pcap	packet.cpp	/^void udp_info_from_pcap(IN const u_char **p_pcap_content, OUT struct Packet *p_packet) {$/;"	f	signature:(IN const u_char **p_pcap_content, OUT struct Packet *p_packet)
udp_info_from_pcap	packet.h	/^void udp_info_from_pcap(IN const u_char **p_pcap_content, OUT struct Packet *p_packet);$/;"	p	signature:(IN const u_char **p_pcap_content, OUT struct Packet *p_packet)
upload	place.cpp	/^void upload(Flow &f) {$/;"	f	signature:(Flow &f)
verification	main.cpp	/^long long verification() {$/;"	f	signature:()
~Flow	flow.h	/^	~Flow() {};$/;"	f	class:Flow	access:public	signature:()
~Switch	switch.h	/^	~Switch() {};$/;"	f	class:Switch	access:public	signature:()
